from environment.environment import RenderMode, CameraResolution, WarehouseBrawl
from environment.agent import run_real_time_match
from user.train_agent import UserInputAgent, BasedAgent, ConstantAgent, ClockworkAgent, SB3Agent, RecurrentPPOAgent #add anymore custom Agents (from train_agent.py) here as needed
from user.my_agent import SubmittedAgent, CustomObservationWrapper
import pygame
pygame.init()

import numpy as np


class TestingUserAgent(UserInputAgent):

    def predict(self, obs):
        user_action = super().predict(obs)

        override_action = self._gen_override_action(obs)

        return user_action if override_action == None else override_action

    def _gen_override_action(self, obs):
        '''Return an action to override the action generated by the model. 
            Return None to use the model action.'''

        move_type = obs[14]
        if move_type != 0: return # in a move still; can't do anything


class TestingConstantAgent(ConstantAgent):
    dt = 1 / 30.0

    # BRAWL_TO_UNITS = 1.024 / 320
    player_hurtbox_size = 0.928, 1.024 # (290//2, 320//2) * 2 * BRAWL_TO_UNITS
    player_collider_size = 0.87, 1

    ground_heights = 2.85, 0.85
    ground_lefts = -7.0, 2.0
    ground_rights = -2.0, 7.0

    # accel; don't multiply by dt
    x_friction = 0.23888889 # towards 0
    y_friction = 0.5936 # always downwards; positive; includes gravity

    jump_vel = -8.9 # velocity is set to this on jump frame; friction is still applied afterwards

    max_fall_speed = 12

    skip_steps = 10

    def __init__(self, *args, **kwargs): 
        super().__init__(*args, **kwargs)

        self.dodge_frames = 0

        self.pred_pos = None
        self.pred_vel = None

        self.prev_vel = None

        self.prev_move_types = [0,0]
        self.move_frames = [0,0]

        # attack data; loaded in self._initialize()
        self.keys = None
        self.attacks = None
        self.spear_attacks = None
        self.hammer_attacks = None

    def _initialize(self) -> None:
        WarehouseBrawl.load_attacks(self)
        print(self.attacks)

    def predict(self, obs):
        super_action = super().predict(obs)

        CustomObservationWrapper._step(self, obs)
        obs = CustomObservationWrapper.observation(self, obs)

        # stun & dodge window
        stun_frames = obs[11]

        if stun_frames == 0:
            self.dodge_frames += 1
        else:
            if self.dodge_frames != 0:
                print("Dodge Frames:", self.dodge_frames)
                self.dodge_frames = 0

            print("Stun:", stun_frames)

        if self.env.steps % self.skip_steps == 0:

            super_action[4] = np.random.random() * 0.55
            jump = super_action[4] >= 0.5
            if jump: print("JUMP")

            # pos
            player_pos = obs[0:2].copy()
            player_vel = obs[2:4].copy()

            if jump: player_vel[1] = self.jump_vel

            if not self.pred_pos is None:
                #print("pred pos error", player_pos[1] - self.pred_pos[1])
                #print("vel change", (player_vel - self.prev_vel) / self.skip_steps)

                #pred_vel_error = player_vel[1] - self.pred_vel[1] 
                #print(pred_vel_error)
                pass

            self.prev_vel = player_vel

            pred_pos = player_pos.copy()
            pred_vel = player_vel.copy()
            
            for i in range(self.skip_steps):
                pred_pos, pred_vel = self.player_physics_update(pred_pos, pred_vel)

            self.pred_pos = pred_pos
            self.pred_vel = pred_vel

        return super_action

    def player_physics_update(self, pos, vel):
        n_vel = vel.copy()

        n_vel[0] -= min(abs(n_vel[0]), self.x_friction) * np.sign(n_vel[0])

        n_pos = pos + n_vel*self.dt

        # handle collision with ground
        on_ground = False

        bot = n_pos[1] + self.player_collider_size[1]/2
        left = n_pos[0] - self.player_collider_size[0]/2 
        right = n_pos[0] + self.player_collider_size[0]/2 

        for i in range(2):
            clip_bot = bot - self.ground_heights[i]
            clip_left = self.ground_rights[i] - left
            clip_right = right - self.ground_lefts[i]

            if clip_left < 0 or clip_right < 0 or clip_bot < -0.001:
                continue # no collision
            
            # collision; find direction to resolve collision with least movement
            if clip_bot < clip_left and clip_bot < clip_right: # move up to resolve
                n_pos[1] -= max(0, clip_bot)
                n_vel[1] = 0
                on_ground = True
            else: # move horizontally to resolve
                if clip_left < clip_right: n_pos[0] += clip_left
                else: n_pos[0] -= clip_right
                n_vel[0] = 0

        #if not on_ground: print(self.env.steps)

        if not on_ground: # game doesn't update y_vel if on ground
            n_vel[1] += self.y_friction

        n_vel[1] = min(self.max_fall_speed, n_vel[1]) # game caps fall speed

        return n_pos, n_vel
        
my_agent = TestingUserAgent()

#Input your file path here in SubmittedAgent if you are loading a model:
opponent = TestingConstantAgent()
#opponent = SubmittedAgent(file_path="./checkpoints/experiment_1/rl_model_20001_steps.zip")

match_time = 99999

# Run a single real-time match
run_real_time_match(
    agent_1=my_agent,
    agent_2=opponent,
    max_timesteps=30 * 60*60,  # Match time in frames (adjust as needed)
    resolution=CameraResolution.LOW,
)